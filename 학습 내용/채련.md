## 들어가며

### 왜 리액트인가?

- 얼마 전(2024년기준) 리액트는 전자정부 표준 프레임워크의 프런트엔드 개발도구로 채택되었다.
- 끝나지 않을 것 같던 제이쿼리의 독점을 2018년 기준으로 리액트가 무너뜨렸으며, 프런트엔드 시장을 완전히 점령하였다.

리액트가 개발자가 선호하는 라이브러리가 된 이유

- 명시적인 상태변경 가능 : 단방향 바인딩
- JSX
- 비교적 배우기 쉽고 간결함
- 강력한 커뮤니티, 메타의 든든한 지원

### 리액트의 역사

2000년대즈음

- LAMP(리눅스, 아파치, mySql, PHP)를 활용해 웹서버에서  html 을 만들어서 클라이언트에게 제공하는 방식으로 작동

2010년도에 들어서며

- 제이쿼리 플러그인
- 인터넷 익스플로러 8에서 로컬 스토리지 등장
- 웹소켓 등장
- 캔버스, svg, 지오로케이션
- ES5 가 표준 스펙으로 자리잡음

2010년 10월쯤

- Backbone.js 등장

그당시 페이스북은?

- 약 7억명정도 회원을 보유하였다
- 실시간성을 강조하는 기능들이 많았다

그리고 스파르탄 프로젝트..

- 애플의 강력한 앱 규제에 반발해 만들어진 프로젝트
- 사파리에서 동작하는 페이스북을 만들기 위해 추진됨
- html5 를 기반으로 하이브리드앱으로 만들려고 했지만 성공하지 못했다.
    - 이유는? 네이티브로 만든 앱이 훨씬 빨랐기 때문..
    - 하이브리드 앱이란? html, css, javascript 로 만들고 앱에서 동작하기 위해 감싼것

BoltJS의 등장과 한계 

- 페이스북팀은 BoltJS 라는 새로운 프레임워크를 만듬
- 하지만 돌연 소스코드가 삭제되었고, 성공하지 못했다
- 이 때 Functional Bolt, Fbolt 가 등장하면서 이것이 훗날 리액트의 시초가 된다
- 이 시대에는 양방향 바인딩 구조의 애플리케이션과 프레임워크가 많았다. 하지만 변경된 DOM의 추적이 어려웠고, 왜 이렇게 변경됐는지 추적하기 어려워서 수많은 버그가 발생하였다.
- 그래서 모델의 데이터가 변경되어 뷰가 변경되어야하면 이전 DOM을 버리고 새롭게 렌더링하는 방식을 제안했다.

## 자바스크립트의 동등 비교

## 06장 데이터

### 자바스크립트의 데이터 타입은 7 + 1개가 있다 (원시타입  +  객체타입)

- 원시타입 - 불변!!(immutable)
    - 숫자 - 다른 언어와 다르게 모든 숫자가 배정밀도 부동소수점으로 되어있다(실수라는 뜻)
    - BigInt - 2^53 - 1 보다 큰 정수를 표현할 수 있는 새로운 원시값! (2011이후 등장)
    - 문자
    - 불리언 - true, false
    - undefined - 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값
    - null - 변수에 값이 없다는 것을 의도적으로 명시할 때 사용
    - 심벌 - 유일무이 특별한 값, 은닉되어있음
- 객체타입 - 자스를 이루는 모든 것이 객체다 , 변할수있는 값!!(mutable)

### 동적타이핑

- 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정된다.
- 또한 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다(변수에 타입이 저장되는것이 아니라 타입은 값이 갖고있는 것 그래서 재할당 될 때 값에 따라 언제든지 변할 수 있다)
- 변수에 할당된 값의 타입이 변환될 수 있다는 것은 편리할 수 있지만 추적하기 어려운 오류를 만들어 내기도 한다.
- 자스는 엔진에의해 암묵적으로 타입이 자동변환 되기도 한다..! ㅂㄷㅂㄷ!

### 변수 선언 시 주의할 사항

- 변수는 꼭 필요한 경우에만 제한적으로 사용한다!
- 변수의 스코프를 최대한 줄여 변수의 부작용을 없앤다
- 전역변수는 최대한 사용하지 않는다 (var를 통한 선언, let과 const 는 전역에 저장되지 않음.)
- 변수보다는 변하지않는다는 의미의 상수값을 이용하자!
- 변수이름을 잘 짓자!
- 오해하지 않는 코드가 좋은 코드 → 가독성이 좋아야 한다.

# 11장 원시값과 객체의 비교

- 원시타입의 값은 변경 불가능한 값이고, 객체타입의 값은 변경 가능한 값이다.
- 원시값을 변수에 할당하면 변수에는 실제 값이 저장된다
- 객체를 변수에 할당하면 객에는 참조값이 저장된다

## 11.1 원시 값

### 11.1.1 변경 불가능한 값

- 한번 생성된 원시값은 읽기전용 값으로 변경불가능하다.

### 11.1.2 문자열과 불변성

- 문자열은 원시값이라 **변경불가능**하다
- 하지만! 유사배열객체이기 때문에
    - 객체처럼 접근하면 배열의 특성을 갖고있다

## 11.2 객체

- 객체는 원시값처럼 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.
- 자바스크립트 엔진은 해시테이블과 유사하지만 나은 성능을 구현하기 위해 히든클래스라는 방식을 사용한다!

### 11.2.1 변경 가능한 값

- 객체 타입의 값, 즉 객체는 변경 가능한 값이다.
- 객체를 할당한 변수는 참조값을 메모리에 저장한다.
    - 객체는 원시값을 저장하는 스택에 저장되지 않고, 힙이라는 메모리 공간에 저장된다.

## 함수

![A1E20952-742A-4C09-BFBD-94F402CFC080.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/d968ede2-5b8a-4ec8-a94b-4a92ce548e96/cbb8d7f3-066a-4768-992e-0da989b1945d/A1E20952-742A-4C09-BFBD-94F402CFC080.jpeg)

![04C04402-1AF7-44C7-BD88-D922AFC07B39.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/d968ede2-5b8a-4ec8-a94b-4a92ce548e96/90382ed0-894a-45d0-866d-94f0b82a46eb/04C04402-1AF7-44C7-BD88-D922AFC07B39.jpeg)

## 12장 함수

- **프로그래밍 언어에서의 함수**
    - 일련의 과정을 문으로 구현하고, 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것이다.
    - 매개변수(parameter) : 함수 내부로 입력을 전달받음
    - 인수(argument) : 입력
    - 반환값(return value) : 출력값
    - **함수는 값이다.**
    - 함수는 함수 정의(function definition)를 통해 생성하고, 함수 호출(function call)로 함수를 실행시킨다.
    - 함수는 필요할 때 여러번 호출할 수 있다. 따라서 **코드의 재사용성 측면**에서 아주 유용하다.
    - 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다.
    - 함수는 객체 타입의 값이라서 **이름(식별자)**를 붙일 수 있다.
    
- **함수 리터럴**
    - 함수는 객체 타입의 값이다. 따라서 함수도 함수 리터럴로 생성할 수 있다.
    - 함수 이름
    - 매개변수 목록
    - 함수 몸체
    - 함수는 리터럴로 생성된다. 따라서 함수 리터럴도 평가되어 값을 생성한다. 이 값은 객체다. **즉, 함수는 객체다.**
    - 함수는 일반 객체와는 다른 일급 객체이다. 일반객체는 호출할 수 없지만 함수는 호출할 수 있다. 그리고 함수 객체만의 고유한 프로퍼티를 갖는다.

- **함수 정의**
    - 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것
    - 정의된 함수는 자바스크립트 엔진에 의해 평가되어 함수 객체가 된다.
    - **함수 정의 방식 4가지**
    - 변수는 선언되고, 함수는 정의 된다. 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.
- 함수 선언문 (표현식이 아닌 문 = 값X)
    
    ```jsx
    function add(x,y){
    	return x + y;
    };
    ```
    
    - 함수 선언문은 함수 이름을 생략할 수 없다.
    - 함수 선언문은 표현식이 아닌 문이다.
    - 함수 선언문은 함수 리터럴과 형식이 같다. 하지만 함수 선언문은 함수 이름 생략 불가능, 함수 리터럴은 생략 가능!
    - 자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수 리터럴을
    - 두 가지로 해석하는 경우가 있다.
    - 자바스크립트 엔진은 **함수 이름이 있는 함수 리터럴을 단독으로 사용**하면 **함수 선언문**으로 해석하고, 함수 리터럴이 값으로 평가되어야 하는 문맥, 예를 들어 함수 리터럴을 **변수에 할당하거나 피연산자로 사용**하면 **함수 리터럴 표현식**으로 해석한다.
    - 결국 함수 선언문은 자바스크립트 엔진이 함수를 호출하기 위해서 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.
    - 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.
    
- 함수 표현식 (표현식인 문 = 값 O)
    
    ```jsx
    var add = function(x,y){
    	return x + y;
    };
    
    console.log(add(2,5));  //7
    ```
    
    - 함수 리터럴(=함수 표현식)은 객체 타입의 값이다. 따라서 변수에 할당 가능 하다.
    - 값의 성질을 갖는 것을 일급 객체라고 한다. (변수에 할당가능, 프로퍼티의 값 가능, 배열의 요소 가능) → 함수를 값처럼 자유롭게 사용할 수 있다는 말
    - 함수표현식은 암묵적으로 함수 이름을 생략하는 것이 일반적임

- 함수 생성 시점과 함수 호이스팅
    - 함수 선언문 으로 정의한 함수
    - 함수 표현식으로 정의한 함수
    - **함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 당연한 규칙을 무시한다!!!** → 함수 표현식을 쓸 것은 권장한다.

- function 생성자 함수
    
    ```jsx
    var add = new Function('x','y','return x+y');
    console.log(add(2,5)); //7 
    ```
    
    - 생성자 함수 : 객체를 생성하는 함수를 말한다.
    - 자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다.
    - 일반적이지 않으며 바람직하지도 않다. 클로저를 생성하지 않는다.

- 화살표 함수
    
    ```jsx
    const add = (x , y) => x + y;
    console.log(add(2,5)); //7
    ```
    
    - 항상 익명 함수로 작성한다.
    - 기존의 함수보다 표현만 간략한 것이 아니라 내부 동작 또한 간략화되있다.
- 함수 호출
    - 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 실행 흐름을 옮긴다. 이 때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행된다.
    - 매개변수와 인수
- 인수 확인
    - 자바스크립트는 매개변수와 인수의 개수가 일치하는지 확인하지 않음
    - 자바스크립트는 동적 타입 언어라 함수는 매개변수의 타입을 사전에 지정하지 않음
    - 따라서, 자스는 함수를 정의할 때 적절한 인수가 전달되었는지 확인할 필요가 있다.
- 매개변수의 최대 개수
    - 이상적인 매개변수 개수는 0개이며 적을수록 좋다.
    - 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.
    - 따라서! 최대 3개 이상을 넘지 않는 것을 권장한다.
    - 만약 3개 이상의 매개변수가 필요하다면 하나의 매개변수를 선언한 후 객체를 인수로 전달하는 것이 유리하다.
- 반환문 (return)
    - 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
    - 반환문 이후의 문을 실행되지 않고 종료된다.
    - 함수 호출은 표현식이다 → 값으로 반환된다.
    - return 키워드 뒤에 오는 표현식을 평가해 반환한다.
    - 만약 return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.
    - 반환문을 생략해도 암묵적으로 undefined가 반환된다.
    - return 키워드와 반환값으로 사용할 표현식 사이에 줄바꿈이 있으면 세미콜론 자동삽입 기능에 의해 세미콜론이 추가된다.
    
    ```jsx
    function multiply(x , y){
    	return  //자동으로 세미콜론이 삽입되어
    	x * y;  //무시된다.. 
    }
    
    console.log(multiply(3,5)); //undefined
    ```
    

- 참조에 의한 전달과 외부 상태의 변경
    - 매개변수에 원시타입의 값이 들어온다면, 원시 타입의 값은 함수 내부에서 동작했을 때 부수효과를 갖지 않는다.
    - 매개변수에 객체 타입의 값이 들어온다면 함수 내부의 문을 통해 외부에서 들어온 객체가 변경될 수 있다. 즉, 부수효과가 있다. 함수로 인해 외부의 객체의 상태변화가 일어난다면 객체의 상태변화를 추적하기 어렵게 되어 코드의 복잡성이 증가한다.
    - 이를 해결하기 위해 객체를 불변 객체로 만들어서 사용하는 방법이 있다.
    - 객체를 깊은 복사를 하여 사용하는 방법도 있다.

## 클래스

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d968ede2-5b8a-4ec8-a94b-4a92ce548e96/f061507f-723a-4964-91b7-1e00377a8661/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d968ede2-5b8a-4ec8-a94b-4a92ce548e96/b699ade6-0b11-4143-a70b-da6ddc937eac/Untitled.png)

## 25장 클래스

### 클래스는 프로토타입의 문법적 설탕인가?

- 자바스크립트는 프로토타입 기반의 객체지향 언어이다.
- 이 말은 클래스가 필요없는 객체지향 프로그래밍 언어다!
- ES5에서는 클래스 없이도 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있었다.
- 사실 클래스는 함수이며, 기존 프로토타입 기반 패턴을 클래스 기반 패턴처럼 사용할 수 있도록 하는 문법적 설탕이라고도 볼 수 있다.
- 단, 클래스와 생성자함수는 프로토타입 기반의 인스턴스를 생성하는 점은 같지만, 정확히 동일하게 동작하지 않는다! 클래스가 좀 더 엄격하고, 생성자함수에서 제공하지 않는 기능들도 제공한다.
- 클래스와 생성자 함수의 다른 점
    - 클래스는 new 연산자 없이 호출되지 않는다. (에러가 발생함)
    - 클래스는 상속을 지원하는 extends, super 키워드를 제공한다.
    - 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. (let, const처럼 동작! TDZ)
    - 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행된다! 해제불가능하다.
    - 클래스의 constructor, 프로토타입 메서드, 정적메서드 모두 프로퍼티 어트리뷰트 [[Enumerable]] 의 값이 false다. 열거되지 않는다.
- 객체 생성방식이 생성자함수보다 좀 더 견고하고, 명료하기 때문에 따라서 클래스를 새로운 객체 생성 매커니즘으로 보는 것이 좀 더 합당하다.

### 클래스 정의

```jsx
//클래스 선언문
class Person {}

//익명 클래스 표현식
const Person = class {};

//기명 클래스 표현식 
const Person = class MyClass {};
```

- 파스칼 케이스를 사용해 선언한다, 파스칼케이스 안써도 에러는 안난다.
- 표현식으로도 클래스를 정의할 수 있다. → 익명, 기명 둘 다 가능 (일반적이지 않음)
- 클래스를 표현식으로 쓸 수 있다는 것은 변수에 할당할 수 있다는 말. 즉, 클래스도 일급 객체다. ( = 함수다)
    - 무명의 리터럴로 생성가능, 런타임에 생성가능
    - 변수나 자료구조(객체, 배열 등)에 저장가능
    - 함수의 매개변수에 전달가능
    - 함수의 반환값으로 사용 가능
- 클래스의 몸체에는 0개 이상의 메서드만 정의할 수 있다.
    - constructor(생성자)
    - 프로토타입 메서드
    - 정적 메서드

```jsx
//클래스 선언문
class Person {
	//생성자
	constructor(name){
		//인스턴스 생성 및 초기화
		this.name = name; //name 프로퍼티는 public하다. 
	}
	
	sayHi(){
		console.log(`Hi My name is ${this.name}`);
	}

	//정적메서드 
	static sayHello(){
		console.log('Hello!');
	}
}

//인스턴스 생성
const me = new Person('Lee');

//인스턴스의 프로퍼티 참조
console.log(me.name); //Lee
//프로토타입 메서드 호출 
me.sayHi();  //Hi! My name is Lee
//정적 메서드 호출 
Person.sayHello();  //Hello!
```

### 클래스 호이스팅 (호이스팅이 발생한다!)

- 함수선언문과 마찬가지로 소스코드의 평가과정에 평가되어 함수객체를 생성한다.
    - 이때 생성하는 함수객체는 constructor이고, 프로토타입도 더불어 생성됨.
- 하지만 클래스는 let, const키워드로 선언한 변수처럼 호이스팅된다. (TDZ에 빠지게됨)
- 따라서! 클래스는 정의 이전에는 참조할 수 없다.

### 인스턴스 생성

- 클래스는 생성자 함수이며, new연산자와 함께 호출되어 인스턴스를 생성한다.
- new연산자를 사용하는것이 필수

```jsx
const Person = class MyClass{};
//이런식으로 기명함수로 만들어서 Person이라는 변수에 담아줬을 때 MyClass는 함수이름이므로 
//함수몸체 내부에서만 사용가능하다. 
//사용하려면 Person 식별자로 인스턴스를 생성해야한다. 
```

### 메서드

- 클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다.
- constructor(생성자), 프로토타입메서드, 정적메서드 세가지가 있다.
- **constructor(생성자)**
    - 인스턴스를 생성하고, 초기화하기 위한 특수한 메서드.
    - 모든 함수 객체가 가지고 있는 prototype 프로퍼티가 가리키는 프로토타입 객체의 constructor프로퍼티는 클래스 자신을 가리키고 있다 → 클래스 = 생성자함수를 의미한다.
    - 클래스의 constructor내부의 this는 클래스가 생성한 인스턴스를 가리킨다.
    - constructor는 만들어질때 메서드로 해석되는 것이 아니다!
    - 클래스가 평가되서 함수객체가 만들어질때 함수 객체 코드의 일부가 된다.
    - 클래스의 constructor메서드와 프로토타입의 constructor프로퍼티는 이름이 같아 혼동하기 쉽지만 직접적인 관련없음!
    - constructor는 클래스 내에 최대 한개만 존재할 수 있음
    - constructor는 생략가능
    - 하지만 constructor를 생략하면 빈 constructor가 암묵적으로 정의된다. → 그럼 빈객체가 생성됨.
    - 인스턴스 초기화
- **프로토타입 메서드**
    - 클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성방식과는 다르게 클래스 prototype 프로퍼티에 메서드를 추가하지 않아도 **기본적으로 프로토타입 메서드**가 된다!
    
    ```jsx
    class Person {
    	constructor(name){
    		this.name = name;
    	}
    	//기본으로 프로토타입 메서드가 된다, 명시적으로 추가해주지 않아도! 
    	sayHi(){
    		console.log(`Hi My name is ${this.name}`);
    	}
    }
    
    const me = new Person('Lee');
    me.sayHi(); 
    ```
    
    - 그리고 인스턴스를 생성하면 자동적으로 인스턴스는 프로토타입 체인의 일원이 된다.
- **정적 메서드**
    - 정적메서드는 인스턴스를 생성하지 않아도 호출할 수 있는 메서드다.
    - static 키워드를 메서드 앞에 붙이면 정적메서드가 된다.
    - 정적메서드는 프로토타입 체인에 들어가지 않고, 클래스에 바인딩된 메서드가 된다.
    - 호출할때도 클래스를 통해서 호출해야 한다.
    
    ```jsx
    class Person {
    	constructor(name){
    		this.name = name;
    	}
    	//정적메서드 
    	static sayHi(){
    		console.log('Hi');
    	}
    }
    ```
    

- 정적메서드와 프로토타입 메서드의 차이
    - 정적메서드와 프로토타입 메서드는 자신이 속해있는 프로토타입 체인이 다르다.
    - **정적메서드 → 클래스로 호출, 프로토타입메서드 → 인스턴스로 호출**
    - 정적메서드 → 인스턴스 프로퍼티 참조불가, 프로토타입메서드 → 인스턴스 프로퍼티 참조가능
    - 프로토타입 메서드는 반드시! 인스턴스를 생성한 후에야 인스턴스를 통해 호출이 가능하다.
    - 하지만 정적메서드는 인스턴스를 만들지 않고도 클래스를 통해서 호출이 가능하다.
    - 만약 인스턴스 프로퍼티를 참조할 필요가 있다면 this를 사용해야 하며 프로토타입 메서드로 정의해야한다.
    - **this를 사용하지 않아도 되는 메서드라면(인스턴스 프로퍼티 참조안하는 메서드) 정적메서드로 만드는것이 좋다!**
    - 예를 들어 표준 빌트인 객체인 Math객체는 다양한 정적 메서드를 가지고 있다.
    - 클래스나 생성자 함수를 일종의 네임스페이스로 사용하는 방법
- 클래스에서 정의한 메서드의 특징
    - function 키워드를 생략한 메서드 축약표현을 사용한다.
    - 클래스에 메서드를 정의할 때는 콤마가 필요없다
    - 암묵적으로 strict mode로 실행된다.
    - for…in 문이나, Object.keys메서드로 열거불가능하다. enumerable의 값이 false이다.
    - 클래스 내부의 메서드는 내부메서드 [[Constructor]]가 없다!!!! non-constructor이다.

### 클래스의 인스턴스 생성 과정

- 암묵적으로 빈 객체 생성(생성할 인스턴스)
- 클래스.prototype이 가리키는 객체로 설정됨
- 암묵적으로 생성된 빈 객체는 this와 바인딩됨
- constructor내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화시킴
- 모든 초기화가 끝나면 암묵적으로 this가 반환되고, 인스턴스가 생성된다.

### 프로퍼티

- 인스턴스 프로퍼티 : constructor내부에서 정의해야함 → 인스턴스 프로퍼티는 모두 public하다!
    - 클래스는 접근제한자(public, private, protected)를 제공하지 않고 있다.
- 접근자 프로퍼티
    - 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다.
    - 클래스에서도 인스턴스 프로퍼티의 값의 조작을 위해 접근자 프로퍼티를 사용가능하다.
    - 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다! (기본적으로 프로토타입 프로퍼티로 설정되므로)
    
- **클래스 필드 정의 제안**
    - 클래스 필드란?(필드 또는 멤버)
    - 자바스크립트에서도 자바같은 클래스 기반 객체지향 언어의 클래스 필드처럼 정의할 수 있는 새로운 표준 사양인 “Class field declaration”이 현재 TC39프로세스의 stage3에 제안되어있다.
    
    ```jsx
    class Person {
    	name = 'Lee';    //클래스 필드정의 , 원래는 constructor안에 정의해야함. 
    									//이 경우 this를 사용하면 안됨, this는 constructor 내부에서만 유효하다.
    }
    
    const me = new Person();
    console.log(me); //Person { name : "Lee"}
    ```
    
    - 클래스 필드 정의하는경우
    - 결국 클래스 필드 정의 제안으로 인스턴스 프로퍼티를 정의할 수 있는 두가지 방식이 만들어졌다
    
- **private 필드정의 제안**
    - TC39프로세스의 stage3에는 private필드를 정의할 수 있는 새로운 표준 사양이 제안되어있다.
    - private 필드의 선두에는 #를 붙여준다, private필드를 참조할때도 #를 붙여야한다.
    
    ```jsx
    class Person {
    	//private필드 정의
    	#name = '';
    	
    	constructor(name){
    		//private필드 참조
    		this.#name = name;
    	}
    }
    
    const me = new Person('Lee');
    
    //private 필드 #name은 클래스 외부에서 참조할 수 없다.
    console.log(me.#name);
    //SyntaxError: Private field '#name' must be declared in an enclosing class
    ```
    
    - private 필드는 클래스 내부에서만 참조 가능하고, 외부에서는 불가능하다
    - private 필드는 접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효하다.
    - private 필드는 반드시 클래스 몸체에 정의해야한다.

- **static 필드 정의 제안**
    - static public 필드, static private 필드는 현재 최신 브라우저에서는 구현되어있다.
    
    ```jsx
    class MyMath{
    	//static public 필드 정의
    	static PI = 22 / 7;
    
    	//static private 필드 정의 
    	static #num = 10;
    
    	//static 메서드
    	static increment(){
    		return ++MyMath.#num;
    	}
    }
    
    console.log(MyMath.PI);  //3.142857142857143
    console.log(MyMath.increment()); //11
    ```
    

### 상속에 의한 클래스 확장 - 코드 재사용 관점에서 유리함

- 클래스 상속과 생성자 함수 상속
    - 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는 것이다.
    - 만약 동물, 새, 사자 를 클래스의 상속으로 표현하고 싶다면
    
    ```jsx
    class Animal {
    	constructor(age, weight){
    		this.age = age;
    		this.weight = weight;
    	}
    
    	eat(){ return 'eat';}
    	move() { return 'move';}
    }
    
    //상속을 통해 Animal 클래스를 확장한 Bird 클래스
    **class Bird extends Animal{
    	fly(){ return 'fly';}
    }**
    
    const bird = new Bird(1,5);
    
    console.log(bird); //Bird{age:1, weight:5}
    console.log(bird instanceof Bird); // true
    console.log(bird instanceof Animal); //true
    
    console.log(bird.eat()); //eat
    console.log(bird.move()); //move
    console.log(bird.fly());  //fly
    ```
    

- extends 키워드
    - 상속을 통해 클래스를 확장하려면 extends 키워드를 사용해 상속받을 클래스를 정의한다!
    - 서브클래스 : 확장된 클래스 , 파생클래스, 자식클래스 라고도 부름
    - 수퍼클래스 : 상속된 클래스, 베이스클래스, 부모클래스 라고도 부름
    - extends 키워드의 역할은 수퍼클래스와 서브클래스간의 상속 관계를 설정하는 것이다.
    - 수퍼클래스와 서브클래스는 **인스턴스의 프로토타입 체인**뿐 아니라 클래스간의 **프로토타입 체인**도 생성한다.

- **동적 상속**
    - extends키워드는 생성자 함수도 상속받아서 클래스를 확장 가능하다!
    - [[Construct]] 내부메서드를 갖는 **함수 객체로 평가될 수 있는 모든 표현식**을 사용할 수 있다!
    
    ```jsx
    function Base1 () {} 
    
    class Base2 {}
    
    let condition = true;
    
    //조건에 따라 동적으로 상속 대상을 결정하는 서브클래스 
    class Derived extends (condition ? Base1 : Base2){}
    
    const derived = new Derived();
    console.log(derived); //Derived {}
    
    console.log(derived instanceof Base1); //true
    console.log(derived instanceof Base2); //false
    ```
    

- **서브클래스의 constructor**
    - 수퍼클래스와 서브클래스 모두 constructor를 생략하면 빈객체가 생성된다.
    - 프로퍼티를 소유하는 인스턴스를 생성하려면, constructor내부에서 인스턴스에 프로퍼티를 추가해야한다.
    
- super키워드
    - 함수처럼 호출할 수 있다.
    - this처럼 식별자같이 참조할 수 있다.
    - 위 두개가 모두 가능한 특수한 키워드임!

## 25장 웅모님 클래스 수업

|  | 클래스 | 생성자함수 |
| --- | --- | --- |
| new | o, x: 에러 | x:일반함수  / o: 생성자함수 |
| extends, super | o | x |
| 호이스팅 | let, const 호이스팅 | 선언문 → 함수호이스팅 / 표현식 → 변수호이스팅 |
| strict mode | o | x |
| [[Environment]] | false | true |
- 다양한 문법 중에서 현재 상황에 맞는 코드를 작성하는 것이 중요하다.
- 어떤 문법이 가장 좋은가? 이런게 중요한게 아님. 어떤 문법이 더 상황에 알맞는지 판단하고, 근거에 의해 선택해서 사용할 수 있어야 한다. 본인의 코드에 본인의 가치판단이 있어야 한다.
- 문법적 설탕 : 동일한 기능을 하는데 좀 더 편하게 만들어놓은 것이 문법적 설탕이다.
- 클래스는 생성자함수의 문법적 설탕이 아니다. 클래스와 생성자함수는 큰 틀에서 보았을 때 인스턴스를 만드는 것은 같지만, 하지만 둘이 같지 않다. 클래스는 new 키워드를 사용했을때 에러를 일으킨다. new 키워드로서 동작하는 추가적인 기능이 있다는 것임!
- 클래스는 자료구조에서 유용하지만, 일반적인 웹을 구현하는데는 잘 안쓰인다.
- 클래스로 이벤트핸들러를 조작하는 것을 만들면 this가 꼬인다!!! 그래서 해결방법으로 화살표함수를 사용한다.
- ESLint 에서 프로토타입 메서드에서 this를 사용하면 빨간줄이 그어진다.
    - 이럴때는 앞에 static을…
- 인스턴스를 못만든다 → 생성자함수가 아니다 → 프로토타입 메서드는 없다! 정적메서드만 있다!
    - constructor 메서드(메서드처럼 생겼지만 사실 메서드는 아니다, 클래스.constructor 사용불가함.)는 생략가능하다. 생성자 함수 내부에 constructor가 풀어진다.
    - ex) Math.max, Math.min 은 인스턴스를 안만들고, 정적메서드만 가지고있다.
    - 메서드체이닝이 다르다? 정적메서드와 프로토타입 메서드 체인이 다르다.

### 상속에 의한 클래스 확장

- super() 가 있어야! 인스턴스를 만들 수 있다. 왜냐면 extends 키워드를 사용해 확장시켜서 서브클래스로 인스턴스를 생성했을 때 사실, 그 인스턴스는 수퍼클래스가 인스턴스를 만들어서 자기의 값을 담아서 서브클래스로 보내는 것이다. 따라서 서브클래스의 constructor를 생략해도 암묵적으로 생기고, 그 내부에 super()가 담겨서 생성된다. 또한, constructor내부의 super()는 꼭! 항상 맨위에 있어야 한다.

### 메서드를 만들때 세가지 선택지

- 생성자함수에 정적메서드를 만들때
- 생성자함수의 프로토타입 객체에 정적메서드를 만든다. (인스턴스를 꼭 봐야할 때 만든다)
    - 인스턴스를 보지 않고 범용적으로 사용할
- 인스턴스에 정적메서드를 만든다.

```jsx
class Stack {
	#elements = [];

	constructor(elements = []) {
		if (!Array.isArray(elements))
			throw new TypeError(`${elements} is not an array`);
		this.#elements = elements;
	}

	push(num) {
		this.#elements.push(num);
	}

	pop() {
		this.#elements.pop();
	}
}

const stack = new Stack([1]);
```

```jsx
class Stack {
	#elements = [];

	constructor(elements = []) {
		if (!Array.isArray(elements))
			throw new TypeError(`${elements} is not an array`);
		this.#elements = elements;
	}

	push(num) {
		this.#elements.push(num);
	}

	pop() {
		this.#elements.pop();
	}
}

const stack = new Stack([1]);
```

## 클로저

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d968ede2-5b8a-4ec8-a94b-4a92ce548e96/a0259dd1-7371-4457-8eb3-924e6f54da35/Untitled.png)

## 23장 실행 컨텍스트

- 자바스크립트의 동작 원리를 담고 있는 핵심 개념!!
- 실행컨텍스트를 이해하면
    - 스코프를 기반으로 식별자와 식별자에 바인딩된 값(식별자 바인딩)을 관리하는 방식
    - 호이스팅이 발생하는 이유
    - 클로저의 동작 방식
    - 테스크 큐와 함께 동작하는 이벤트 핸들러
    - 비동기 처리의 동작 방식
- 소스코드의 타입 → 4가지 타입의 소스코드는 실행컨텍스트를 생성한다.
    - 전역코드 : 전역에 존재하는 소스코드를 말한다. 전역에 정의된 함수, 클래스 등의 내부 코드는 포함되지 않는다.
    - 함수코드 : 함수 내부에 존재하는 소스코드를 말한다. 함수 내부에 **중첩된 함수, 클래스 등의 내부 코드는 포함되지 않는다.**
    - eval코드 : 빌트인 전역 함수인 eval함수에 인수로 전달되어 실행되는 소스코드를 말한다.
    - 모듈코드 : 모듈 내부에 존재하는 소스코드를 말한다. 모듈 내부의 함수, 클래스 등의 내부 코드는 포함되지 않는다.

- 전역코드
    - 전역 변수를 관리하기 위해 최상위 스코프인 전역 스코프를 생성한다.
    - 전역코드가 평가되면 실행 컨텍스트가 생성된다.
    - var키워드로 선언된 전역변수 → 전역객체의 프로퍼티와 바인딩
    - 함수선언문으로 정의된 전역함수 → 전역객체의 메서드로 바인딩
    - 이 프로퍼티와, 메서드를 참조하기 위해 전역객체와 연결해야한다.

### 렉시컬 환경 (lexical environment)

- 식별자
- 식별자에 바인딩된 값
- 상위 스코프에 대한 참조
- 위의 세가지를 기록하는 자료구조. 실행 컨텍스트를 구성하는 컴포넌트다.
- 실행 컨텍스트는 LexicalEnvironment컴포넌트와 VariableEnvironment컴포넌트로 구성된다. 그리고 이것들은 처음에는 둘 다 렉시컬 환경을 참조하고 있다가, 이후 몇가지 상황을 만나면 VariableEnvironment 컴포넌트를 위한 새로운 렉시컬환경을 생성하고, 그 이후부터는 두개의 컴포넌트가 내용이달라질 수 있다.
- 렉시컬 환경은 두 개의 컴포넌트로 구성된다.
    1. 환경레코드(Environment Record) : 스코프에 식별자를 등록하고, 바인딩된 값을 관리하는 저장소. 소스코드에 따라 관리하는 내용에 차이가 있음.
    2. 외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference) : 상위 스코프를 가리킴. 즉, 실행컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 말함! 이를 통해 단방향 링크드리스트인 스코프체인을 구현한다. 

### 실행컨텍스트의 생성과 식별자 검색 과정

1. 전역객체 생성 : 전역코드가 평가되기 이전에 가장 먼저 생성되는것 
    1. 빌트인 전역 프로퍼티, 빌트인 전역함수, 표준 빌트인 객체가 추가됨. 
    2. 동작환경에 따라 Web API 또는 특정 환경을 위한 호스트객체를 포함한다. 
    3. 전역객체도 Object.prototype을 상속받으므로, 프로토타입 체인의 일원이다.
2. 전역코드 평가 전체 구조 
    1. **전역 실행 컨텍스트 생성**  
    2. **전역 렉시컬 환경 생성**
3. 전역코드 평가 세부 내용
    1. 전역 실행 컨텍스트 생성
    2. 전역 렉시컬 환경 생성
    3. 전역 환경 레코드 생성 (2개의 레코드로 나뉨!)
    4. 객체 환경 레코드 생성
    5. 선언적 환경 레코드 생성 (let, const 로 전역에 선언한 식별자 관리)
    6. this 바인딩 
    7. 외부 렉시컬 환경에 대한 참조 결정 
4. 전역 코드 실행 
    1. 평가가 끝나고 난 다음 전역 코드가 순차적으로 실행된다. 
    2. 식별자 결정을 위해 식별자를 검색할 때는 실행중인 실행 컨텍스트에서 식별자를 검색하기 시작한다. 
    3. 현재 실행 컨텍스트에 식별자가 없다면 외부(상위스코프)에서 식별자를 찾기 위해 outerLexicalEnvironmentReference 의 참조값을 통해 외부로 가서 식별자 검색을 한다.
5. 함수 코드 평가 (함수 호출문을 만났을 때 실행컨텍스트가 만들어짐)
    1. 함수코드의 평가도, 전역 실행 컨텍스트가 만들어지는 순서대로 똑같이 생성된다. 
    2. 함수 실행 컨텍스트 생성 
    3. 함수 렉시컬 환경 생성 
    4. 함수 환경 레코드 생성 (함수 렉시컬 환경중 첫번째 컴포넌트)
6. 함수 코드 실행 
    1. 매개변수에 인수가 할당됨
    2. 변수할당문이 실행되어 지역변수에 값이 할당됨. 
    3. 식별자 결정을 위해 첫번째로는 현재 실행중인 실행컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작한다. 
    4. 만약 없다면 outerLexicalEnvironmentReference의 참조값을 따라서 식별자를 검색하러 간다.
    5. 식별자를 찾았다면 값을 바인딩한다.  
7. 렉시컬 환경은 실행 컨텍스트에 의해 참조되기는 하지만 독립적인 객체다. 
    1. 객체를 포함한 모든 값은 누군가에 의해 참조되지 않을 때 비로소 가비지 컬렉터에 의해 메모리 공간의 확보가 해제되어 소멸한다. 
8. 모든 코드들이 실행되고, 참조되지 않는다면 전역실행컨텍스트도 스택에서 빠져나가서 코드가 끝나게 된다. 

### 실행컨텍스트와 블록레벨 스코프

- 코드블록을 만나면 블록 레벨 스코프를 생성해야 한다.
- 선언적 환경 레코드를 갖는 **렉시컬 환경을 새롭게 생성**하여 기존의 **전역 렉시컬 환경을 교체**한다!
- 블록레벨 스코프는 let과 const에만 적용된다는것 잊으면 안됨

## 24장 클로저

- 클로저는 자바스크립트 고유의 개념이 아님
- 함수를 일급객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.
- 자스의 개념이 아니기 때문에 ECMAScript 사양에 등장하지 않는다.
- 클로저는 이렇게 정의되고 있다
    - 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.

### 렉시컬 스코프

- 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조(outer lexical environment reference)”에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 환경에 의해 결정된다.

### 함수 객체의 내부 슬롯

- 함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.
- 즉, 내부슬롯에는 함수 정의가 평가되어 함수 객체가 생성될때! 현재 실행중인 실행 컨텍스트의 렉시컬 환경을 가리킨다!

### 클로저와 렉시컬 환경

- 외부함수보다 중첩함수가 더 오래 유지되는 경우 중첩함수는 이미 생명 주기가 종료한 외부함수의 변수를 참조할 수 있다. 이러한 중첩함수를 클로저 하고 부른다!
- 실행 컨텍스트가 스택에서 팝 된다고 해서 렉시컬 환경까지 같이 사라지는 것은 아니다! 누군가가 참조하고 있다면 렉시컬 환경은 남아있다.
- 그렇다는 것은.. 중첩함수의 외부함수 내의 지역변수들까지 모두 기억하고 있다는 것임!
- **클로저라고 하지 않는 중첩함수들**
    - 중첩함수지만, **내부함수가 상위스코프의 어떤 식별자도 참조하지 않는다**면 모던 브라우저의 경우 최적화를 통해 상위 스코프를 기억하지 않는다. → 그렇다면 클로저가 아니다.
    - **외부함수보다 내부함수의 생명주기가 짧다!** → 내부함수가 상위스코프의 식별자를 공유하고 있다면 클로저가 맞지만 사실 이렇게 만든다면 클로저의 본질과 부합하지 않다.
- 그래서 클로저란?
    - **중첩함수가 상위 스코프의 식별자를 참조하고 있고, 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정하는 것이 일반적임!**
- 모던 브라우저에서의 식별자 관리
    - 만약 실행컨텍스트가 종료되고, 내부함수의 식별자 참조에 의해 남아있는 외부함수의 렉시컬 환경은 모두 다 가지고있는 것이 아니다.
    - 내부함수에서 참조한 식별자의 종류만 걸러내서 남겨놓고 나머지 참조하지 않는 식별자들은 가비지콜렉터에의해 지워진다.
- 클로저에 의해 참조되는 상위 스코프의 변수 - **자유변수(free variable)**이라고 부른다.
    - 클로저는 함수가 자유변수에 대해 닫혀있다 라는 의미이다.
    - 즉, 자유변수에 묶여있는 함수 라고 할 수 있다.
    

### 클로저의 활용

- 클로저는 **상태를 안전하게 변경하고 유지**하기 위해 사용한다.
- 상태를 안전하게 **은닉**하고, **특정 함수에게만 상태변경을 허용하기 위해 사용**됨.
- 즉시실행함수와 함께 사용하면 클로저를 만들 수 있다.

```jsx
const increase = (function (){
    let num = 0;

    return function(){
        return ++num;
    }
}());

console.log(increase()); //1
console.log(increase()); //2
console.log(increase()); //3
```

- 변수값은 누군가게 의해 언제든지 변경될 수 있다는 점을 항상 기억해야 한다.
    - 외부 상태 변경이나 가변데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다!
- 클로저를 사용하는 방법
    - 즉시실행함수 내부에 return 함수
    - 즉시실행함수와 함께 return { 함수 여러개 }
    - 즉시실행함수 내부에 생성자 함수도 만들 수 있음
    - 함수형 프로그래밍..

### 캡슐화와 정보은닉

- 캡슐화란 (프로퍼티 + 메서드, 정보은닉)
    - 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
    - 프로퍼티 + 메서드
    - 정보 은닉 : 또한 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 한다.
    - 정보은닉

## 웅모님 강의 this

## this

- 함수가 객체 내에 묶여있으면 객체 내의 함수는 자유롭게 쓸 수 없다.
- 따라서 묶이지 않고 메소드를 자유롭게 쓸 수 있게 하기 위해서 this를 사용하는 것임.
- 함수는 call, constructor 모두 가지고 있으므로 일반함수호출, 생성자함수호출, 메서드호출 모두 가능하다.. 그래서 코드 짤때 주의해야한다.  → 함수 호출할때 주의해야한다!!!
- 중첩함수나, 콜백함수에서 this가 외부함수와 다르게 나오는것 ⇒ this의 불일치 문제.
- 주석을 안달려면 함수이름을 잘지어라,, 요즘은 코멘트는 안다는게 대세임
- 화살표함수는 스코프를 만들지만 this값이 없다. 그래서 화살표 함수 내에서 this를 발견하면 식별자로 이해하고 상위 스코프에서 this를 찾기 때문에! 화살표함수 내부의 this는 상위스코프의 this를 가리키게 된다.
- 인터페이스라는 것은 항상 외부와 내부가 있는 것이다. 어떤 것을 이어주는 뜻이기 때문에
- 콜백함수의 상위스코프는 외부함수다!!!! setTimeout함수가 아님. 매개변수로 받아온것이기 때문에 외부에서 내부로 온것임!!!!! 그래서 콜백함수의 상위스코프는 외부함수다.
- setTimeout함수는 직접 호출하는 것이 아니라 콜백함수는 브라우저가 호출하는것임. setTimeout은 그저 타임아웃을 설정해주는 것 뿐임. → 셋타임아웃은 시간을 셀 뿐이고, 브라우저가 시간을 주시하고있다가 콜백함수를 호출하는 것이다.
- 매개변수는 입구다, 매개변수로 받는 인수들은 원래 갖고있던게 아니라 외부에서 들어온 것이다.
    - 이 말은, 콜백함수도 매개변수로 받은것이기 때문에 setTimeout(function,1000)에 들어간 콜백함수 function 은 외부에서 온 것이다. 따라서!!!!! 콜백함수의 상위스코프를 잘 봐야한다.. setTimeout이 상위스코프가 아님! 매우중요! 착각금지!
- 중첩함수나 콜백함수에서 this가 꼬이지 않게 하려면(상위 스코프와 this를 일치시키려면) 화살표함수가 가장 적절하다,,
- 호출이란? →함수호출이라는 것은 호출을 해서 그 당시에
- 함수 객체가 태어난다 → 호출 되었을 때 함수객체가 없으면 호출을 못하기 때문에 어디선가 호출되었을 때 읽을 수 있게 하기 위해 함수 내부의 문자열을 만들어놓고, 실행되게 하는 것. 함수객체와 함수 몸체는 따로 생성되는것이다.
- 함수선언문은 런타임 전에 함수객체가 생성된다는 말은, 완전한 객체가 생성된다는 것이 아니라 객체만 만들어지는 것이고, 함수몸체는 아예 읽지 않은 상태다. 나중에 호출이 되면, 그 때 완성되어있는 함수객체 에 함수몸체를 평가하기 시작하는 것이다.
- 프로퍼티키와 비어있는 값은 존재할 수 없다. 항상! 컴퓨터는 키에 뭔가라도 값을 넣어줘야 한다.
- const f = function (){} 을 만들게 될때, 런타임 전에는 f라는 식별자를 스코프에 등록하게 되고, 등록하면 값을 꼭 함께 넣어줘야 한다. 하지만 const라서 할당은 런타임때 된다. 그렇다면 const f 에 할당이 되기 전에는 레퍼런스에러를 처리해버리는데! 그 레퍼런스에러를 발생시키려면 런타임 이전에 f 에 어떠한 값을 넣어줘야 컴퓨터가 그 값을 평가해서 레퍼런스에러를 일으키게 된다. 그래서 결국! 런타임 이전에 f에는 어떤 값이 들어가지는 모르지만! 레퍼런스에러가 뜨도록 만드는 어떠한 하나밖에 없는 유일한 에러를 일으키는 값을 넣어주게 된다.
- 함수객체를 만드는 것과, 함수몸체를 만드는 것은 다르다.
    - 함수객체를 만드는 것은 함수가 가지고 있는 내부슬롯이나, 프로퍼티들을 저장하는 것이다. 상위스코프도 결정해야한다. 함수객체로서 가지고있어야 할 것들을 만들어 놓는 것임! 함수몸체의 코드는 절대안봄
    - 또한 함수객체가 만들어지면 객체가 되기 위해 필요한 값을 문자열로 가지고 있는 것이다.
    - 함수몸체가 만들어지는 것은 함수가 호출이 되었을 때 그때 함수몸체의 코드를 읽는다는 것이다.

```jsx
Math.max(1,2,3); //3

const arr = [1,2,3];

Math.max.apply(null,arr); //spread문법이 없던 시절.. apply문법을 사용했다. 

요즘은 스프레드를 사용하면 된다. 
Math.max(...arr);

[...arr];  // [1,2,3]

slice를 사용해서 복사한다는 말은 원래 slice는 start부분과 end부분을 지정해줘야하는데 
지정을 안해준다면?! 처음부터 끝까지 잘라서 복사해라! 이런뜻이므로 복사할 수 있게 된다. 
```

- apply와 call의 본질은 자기 마침표 앞의 객체를 **호출**하는 것이 본질이다.
- bind의 본질은 this를 갈아끼우는 것이 본질이다. 그래서 호출까지 안해오는것임.

- 유사배열객체

```jsx
const arrayLike = {0:1, 1:2, length:2}
Array.prototype.slice.call(arrayLike); // (2) [1,2]

요즘 방법 
스프레드방법은 뒤에 꼭 이터러블이 와야한다!!! 그래서 [...arrayLike] 작동안함. 
Array.from(arrayLike)  // (2) [1,2]
```

- this 파트의 핵심은 this의 불일치 상태에서 어떻게 일치시킬지다!
    - that에 this 할당
    - bind() 메서드 사용
    - arrow function 사용

- 전역코드는 전역스코프를 만들어야한다.
    - ES5시절에서는 윈도우가 전역객체의 역할을 했다.
    - 전역스코프 역할을 하는 친구가 두개가 있다.

## 웅모님 강의 실컨, 클로저

- 이벤트핸들러도 클로저 처럼 동작함. 이벤트핸들러(클릭을 할때는 실행컨텍스트가 비어있을 것임. 이미 다 코드가 끝났기 때문에, 하지만 클릭했을때 뭔가 동작하면서 함수가 동작한다? 이말은 렉시컬스코프만 남아있어서 참조한다는 것이다. 클로저랑 동작이 같음)
- 비동기처리도 클로저와 비슷하다!!!!
- 스크립트 태그로 파일이 들어오면 바로 전역코드 평가가 시작되는것이다!
    - 이 말은, 전역실행컨텍스트가 먼저 만들어지고, 전역 렉시컬환경이 만들어진다는 말!
- 변수선언이란 : 변수 식별자의 존재를 자바스크립트 엔진에게 알린다. → 자바스크립트 엔진이 식별자의 존재를 안다 → 어딘가에 적어놔야한다. → 실행컨텍스트에 적어놓는다! 전역코드의 평가단계에
- 코드가 실행되다가 함수호출문에 의해 흐름이 옮겨졌다? 이것이 실행컨텍스트로 알 수 있는 것이다.
- 실행컨텍스트는 LexicalEnvironment, VariableEnvironment 두개의 컴포넌트로 나뉘지만 이것은 아주 특수한 상황에서만 나뉜다!
- 함수객체는 heap에 저장된다!
- this 값은 누가 가지고있냐?! ES6에서는 **환경레코드의 내부슬롯**으로 가지고 있다!
    - 전역에서의 this는 무조건 전역객체를 가리킨다!
    - this는 키워드지만(미리 예약어로 되어있다), 식별자처럼 동작한다.
- 평가와 실행을 나눈 것은, 실행을 위한 준비단계를 나눈것으로 보면 된다. 이 말은 식별자를 미리 스코프체인을 만들고나서 실행시키려는 것이다. 그래서 평가단계는 거의 식별자 등록이 이루어진다!! 그다음 실행단계에서 할당이 이루어지고 여러가지가 이루어진다. 그리고 스코프 체인은 만들어진 렉시컬환경들의 구조이다.
- 식별자네이밍규칙 중요
- 브라우저를 켜는 순간 window라는 식별자가 만들어지고, 전역객체가 만들어진다.
    - 따라서 브라우저를 끄지 않는 이상은! 전역객체는 사라지지 않는다!
- 클로저는 상태를 안전하게 유지하기 위한 방법이다. 정보은닉의 개념으로 사용된다~
- 클로저 : 자신의 상위 스코프를 언제나 기억하고 있으면 클로저. 그래서 자바스크립트는 기본적으로 함수는 전부 클로저이다. 중첩함수가 외부함수보다 더 오래 살아남아서 사용되는 것을 클로저라고 부른다.
- 버튼을 클릭하면 브라우저가 동작해주세요! 뭐를? 내가 지정한 함수를 호출해서 동작하게 해주세요.

```jsx
<body>
		<pre>0</pre>
		<button>+</button>
		<script>
			const increase = (() => {
				let count = 0;

				return () => {
					count += 1;
					console.log(count);
				};
			})();

			document.querySelector('button').addEventListener('click', () => {
				increase();
			});
		</script>
	</body>
```

- 함수형 프로그래밍이라는 것중 중요한 개념은, 함수가 일급객체라는 것이다. 이 중 더 핵심은 함수는 값이기 때문에 return 할 수 있는 점이다.
- 모듈코드 : 모듈코드가 실행이 되면 실행컨텍스트를 만든다. 즉, 모듈이 생기면 자신의 렉시컬 스코프를 만들게 된다! 따라서 모듈은 모듈의 스코프를 만든다~
- 렉시컬 환경을 이용해 프라이빗을 구현하는 것입니다.
- 클로저에서 중첩함수는 꼭 원시값만 프라이빗으로 가질 수 있는것이 아니고, 함수도 가질 수 있다

- 캡슐화를 프로그래밍화 한다면 : 약을 캡슐안에 넣는것처럼, 프로퍼티나 메소드들을 풀어놓지 말고 한 곳에 모아놓는 개념이 캡슐화다!
- 정보은닉 : 정보은닉이란! 외부에서 볼수있게 하고, 못보게하는것이 은닉이다.
- 공개되어있는 변수들은 다른사람과 함께 코드를 짤때에도 다른사람들이 변수를 쓰라는건지 말라는건지 알 수 없다. 따라서 공유되지 않는 변수들은 숨겨놓는것이 가장 좋다! 헷갈리지 않게!!! 코드 입장에서도, 협업을 하는 입장에서도 정보은닉은 중요하다. 코드는 오해하지 않고, 실수하지 않게 써야 한다. 전역변수는 절대 사용하면 안된다.
- 정보
    - 외부에 공개할 필요가 있는 것만 공개해야 한다.
    - 바뀔 가능성이 있는 것도 최대한 안보여주는 것이 좋다!
- 자바스크립트에서는 private라는 개념이 없어서 클로저로 묶어주는 것이다. 하지만 결국은 클로저로 정보은닉이 완벽하게 되지 않는다(인스턴스를 여러개 만드는 상황). 그래서 현시점에서는 인스턴스를 여러개 만드는 상황에서는 클래스의 private를 사용해야한다~ 필수불가결이다~ 그래서 이런 상황(인스턴스 많이만들어야되는 상황)이외에는 왠만해서는 함수를 사용하는 것이 좋다! 적절하게 함수형과 클래스를 섞어서 가독성 좋게 사용하면 된다!

- 우리가 인수로 들어온 값이 오브젝트인지 아닌지 확인할 때 typeof로 확인할 때의 문제점
    - null 을 넣으면 ‘object’가 나온다
    - function을 넣으면 ‘function’이 나온다!